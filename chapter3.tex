%Status: 5 lorems construction?
%Todo: php Qt hozzáférés
%----------------------------------------------------------------------------
\chapter{Központi egység}
%----------------------------------------------------------------------------

\begin{figure}[!ht]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/rp3-and-display.png}
	\caption{Raspberry Pi 3 érintõkijelzõvel } 
\end{figure}

Ennél az egységnél szerettem volna kipróbálni a Qt for Device Creation keretrendszert. A legjellemzõbb felépítés, hogy egy Linux rendszermagra és egy ablakozórendszerre támaszkodva fut a Qt-ban megírt szoftver. Elõnye a teljes rugalmasság, és a gyors fejlesztési és tesztelési ciklusok. Hátránya, hogy kicsivel erõsebb hardvert igényel, mint az alacsony szinten megírt beágyazott rendszerek, de a nagyobb teljesítmény\H{u} SOC-ok (System on a Chip) olcsóvá válása ezt a faktort jelentéktelenné tette.

Mivel a Qt for Device Creation liszenszköteles, ezért a Qt keretrendszer nyilt forráskódú, ingyenesen hozzáférhetõ változatát használtam a fejlesztéshez. Ez a szoftver elkészítése szempontjából semmilyen különbséget nem jelentett, inkább elõny volt, mert hozzáférésem volt számos felhasználói programhoz, amik segítséget nyújtottak a fejlesztés során.

A teljes konstrukció  áll egy kártya PC-bõl, amire egy érintõkijelzõ kerül. A kép a számitógép HDMI csatlakozóján, az érintésinformáció SPI interface-en keresztül kerül átvitelre. 

%----------------------------------------------------------------------------
\section{Hardver}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Raspberry Pi 3}
%----------------------------------------------------------------------------

A Linux-ot futtató board szerepét egy Raspberry Pi 3 játsza. A feladathoz szükséges számítási kapacitás többszörösével rendelkezik, de mivel az elkészülendõ szoftver platformfüggetlen, ezért késõbb tömeggyártás esetén egyszer\H{u}en portolható olcsóbb hardverre is. Elõnye a 3-as verziónak, hogy nem igényel WiFi modult, mivel már intergrálva tartalmazza azt.

\blindtext

Saját gyártmányú board is készíthetõ lett volna, amihez számtalan nyílt forráskódú (hardver esetén kapcsolási rajz, alkatrészlista) adhatott volna kiindulási alapot. Azonban a Raspberry Pi 3 univerzalitása és kedvezõ ára értelmetlenné teszi, hogy egy lényegében ugyanolyan, de az alacsony példányszám miatt többszörösébe kerülõ eszköz készüljön el, jelentõs fejlesztési idõt felemésztve. 

%----------------------------------------------------------------------------
\subsection{Érintõkijelzõ (Elecrow 5 inch display for Raspberry Pi)}
%----------------------------------------------------------------------------

Olyan kijelzõt kerestem, aminek a mérete már megfelelõ egy ujjal kezelhetõ interface kialakításához. A kijelzõ legfontosabb tulajdonságai:

\begin{itemize}  
	\item 800x480 TFT kijelzõ
	\item HDMI képinterface
	\item Rezisztív érintésérzékenység (SPI interface)
\end{itemize}

A beszerzett kijelzõ meglehetõsen gyenge minõség\H{u}nek bizonyult. A érintési pontokat pontatlanul adta viszza, amint még kalibrációval sem nagyon tudtam javítani. Képernyõ betekintési szögei gyengék, a színek mosottak és kontraszttalanok még szembõl nézve is. 


%----------------------------------------------------------------------------
\section{Szoftver}
%----------------------------------------------------------------------------

Mivel a központi egység egy teljes érték\H{u}, Linuxot (Raspbian Jessie) futtató számítógépre, ezért technológiák széles palettájából válogathattam. A grafikus felület Qt keretrendszer segítségével készült el. A további webszerver funciók megvalósításához a LAMP (Linux + Apache + MySQL + PHP) nagy népszer\H{u}ségnek örvendõ megoldáscsomagot használtam. Az egyszer\H{u}ségnél és a kompaktságnál fontosabb szempont volt minél több területrõl fejlesztési tapasztalatot szerezni. 

%----------------------------------------------------------------------------
\subsection{Az alkalmazás}
%----------------------------------------------------------------------------

%A qt bemutatása
%az alkalmazás funkciói
A qt bemutatása: \blindtext

A alkalmazás funkciói: \blindtext \blindtext

\begin{figure}[!ht]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/placeholder.png}
	\caption{Az alkalmazás fõoldala} 
\end{figure}


\begin{figure}[!ht]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/placeholder.png}
	\caption{Az alkalmazás (részleges) UML osztálydiagrammja} 
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Automatizálás}
%----------------------------------------------------------------------------

Ki lehetne t\H{u}zni célul, hogy az rendelkezésre álló eszközöket felhsználva, bármilyen köztes logika leprogramozható legyen. Másképp megfogalmazva, bármely beszélt nyelven megfogalmazható egzakt m\H{u}ködés implementálható legyen. Az információelméletben használt Turing teljesség hasonló tartalmat definiál precízen.
Egy ilyen rendszer implementálása meglehet?sen sok idõt vesz igénybe. Megoldás lehet valamely ECMAScript (Javascript) implementáció felhasználása.
Qt keretrendszer alatt rendelkezésre áll QtScript modul (bár elavulttá lett nyilvánítva), vagy bármely más modern motor, mint a Google V8-a vagy a Mozilla
SpiderMonkey-ja. Az eszközök ekkor mint objektumok elérhatõvé tehet?k.
Ennél én egy egyszer?bb, rögzített számú paraméterb?l álló utasításleíró nyelvet valósítottam meg, a következõ adatokkal
\begin{itemize}  
	\item forrás eszköz azonosítója
	\item forrás paraméter (részletesen a \ref{sec:parameters} pontban)
	\item operátor: a forrás paraméter és a konstans közötti logikai "<" és ">" m\H{u}velet
	\item konstans: tetszõleges szám
	\item utasítás
	\begin{itemize}
		\item link: a feltétel logikai értéke mindenkor megegyezik a célparaméterrel
		\item set: ha igazzá válik a feltétel 1-re állítja a célparamétert
		\item reset: ha hamissá válik a feltétel 0-re állítja a célparamétert
	\end{itemize}
	\item cél eszköz azonosítója
	\item cél paraméter	(részletesen a \ref{sec:parameters} pontban)
\end{itemize}

\textbf{Programozási példa 1.: } Szeretnénk, ha egy lámpa (8396086 azonosítóju WiFi-s aljzatra kötve), abban az esetben ha a kinti napfény már nem elegendõ a jó látási viszonyok biztosításához (amit a 8398241 környezeti szenzor mér), automatikusan felkapcsolódna, és napfelkeltéig úgy is maradna:

\begin{lstlisting}
8398241 ambient < 10 link 8396086 relay
\end{lstlisting}

Teszteléskor a lámpa többször fel és lekapcsolódott. A lámpa felkapcsódásakor a mért fényerõsség 10.6 lux volt. A hibát tehát az okozza, hogy a lámpa fénye visszahat a fényszenzor által mért értékre. Megoldás lehet a hiszterízises kapcsolás: 

\begin{lstlisting}
8398241 ambient < 9.5 set 8396086 relay
8398241 ambient < 10.5 reset 8396086 relay
\end{lstlisting}

\textbf{Programozási példa 1.: } A üvegházban a növények nem szeretik ha 5 C\textdegree ~alá megy a hõmérséklet, de még nagyobb a baj, ha az fagypont alá csökken. Ezen események detektálása lehetséges egy környezeti szenzor segítségével (azonosító: 8398241):

\begin{lstlisting}
8398241 temperature < 5 set 8398241 ledblue
8398241 temperature < 0 set 8398241 ledamber
\end{lstlisting}

Az eseményt jelzõ ledek kikapcsolhatóak a központi egységen.

Ennek az egyszer? utasításnyelvnek a legnagyobb korlátja az, hogy csupán egy adat alapján tud döntést hozni, ráadásul a kimenet is csak logikai lehet. Folytonos szabályzás például nem valósítható meg ilyen módon. Véleményem szerint, ha széles tömegeknek készül a termék,  akkor akár ez a limitált funkcionalitás is elegendõ lehet.




%----------------------------------------------------------------------------
\subsection{A webszerver}
%----------------------------------------------------------------------------

Az IOT egyik alapelve a meglévõ webes szabványok alkalmazása, ezért a központi egység egy teljes érték\H{u} webszervert valósít meg. Ehhez az Apache HTTP Server \cite{wiki-apache} nyílt forráskódú alkalmazást vettem igénybe, kiegészítve a PHP \cite{wiki-php} (PHP: Hypertext preprocessor) modullal. Mivel az összes rendelkezésre álló adat egy adatbázisban tárolódik, ezért akár a grafikus alkalmazástól teljesen függetlenül, bármely funkció tisztán webes alapon is implementálható.

A m\H{u}ködéhez létfontosságú egyetlen funkció a nyitásérzékelõ modul számára nyújtott interface, melyet a következõ PHP kód valósít meg:

\lstinputlisting[language=PHP]{source/opendetectorPhp.txt}

%----------------------------------------------------------------------------
\subsection{Az adatbázis}
%----------------------------------------------------------------------------

A grafikus alkalmazás, az alapvetõ konfiguráción kívül nem tárol adatot, ehelyett azokhoz lekérdezéseken keresztül jut hozzá. Ehhez a MySQL \cite{wiki-mysql} relációs adatbáziskezelõ rendszerét használom. Az okosotthon rendszerhez egy külön adatbázist hoztam létre \textbf{smarhome} alapértelmezett névvel, a következõ táblákkal:

\begin{table}[ht]
	\footnotesize
	\centering
	\caption{A nyitásérzékelõ adatbázis struktúrája: \textbf{opendetector}}
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Név} & \textbf{Típus} & \textbf{Extra} & \textbf{Leírás} \\ 
		\hline
		ID & int & AUTO\_INCREMENT & a bejegyzés azonosítója \\
		\hline
		DEVICE & int &  & az eszköz azonosítója \\
		\hline
		OPEN & tinyint &  & 0:csukott 1:nyitott állapot \\
		\hline
		TIMESTAMP & timestamp & CURRENT\_TIMESTAMP & a bejegyzés dátuma és ideje \\
		\hline
	\end{tabular} 
\end{table}

\begin{table}[ht]
	\footnotesize
	\centering
	\caption{A környezeti szenzor adatbázis struktúrája: \textbf{envirnmentalsensor}}
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Név} 	& \textbf{Típus} 	& \textbf{Extra} & \textbf{Leírás} \\ 
		\hline
		ID & int & AUTO\_INCREMENT & a bejegyzés azonosítója \\
		\hline
		DEVICE & int &  & az eszköz azonosítója \\
		\hline
		TIMESTAMP & timestamp & CURRENT\_TIMESTAMP & a bejegyzés dátuma és ideje \\
		\hline
		TEMP & decimal &  & Hõmérséklet \\
		\hline
		PRESS & decimal &  & Légnyomás \\
		\hline
		HUM & decimal &  & Páratartalom \\
		\hline
		AMB & decimal &  & Környezeti fény \\
		\hline
		R & int &  & piros csatorna számlálója \\
		\hline
		G & int &  & zöld csatorna számlálója \\
		\hline
		B & int &  & kék csatorna számlálója \\
		\hline
		W & int &  & fehér csatorna számlálója \\
		\hline
	\end{tabular} 
\end{table}

\begin{table}[ht]
	\footnotesize
	\centering
	\caption{A programozható aljzat adatbázis struktúrája: \textbf{wifisocket}}
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Név} 	& \textbf{Típus} 	& \textbf{Extra} & \textbf{Leírás} \\ 
		\hline
		ID & int & AUTO\_INCREMENT & a bejegyzés azonosítója \\
		\hline
		DEVICE & int &  & az eszköz azonosítója \\
		\hline
		TIMESTAMP & timestamp & CURRENT\_TIMESTAMP & a bejegyzés dátuma és ideje \\
		\hline
		POWER & decimal &  & a felvett teljesítmény \\
		\hline
		VOLTAGE & decimal &  & a mért feszültség \\
		\hline
		CURRENT & decimal &  & a mért áram \\
		\hline
		POWERFACTOR & decimal &  & a teljesítménytényezõ \\
		\hline
	\end{tabular} 
\end{table}

\begin{table}[ht]
	\footnotesize
	\centering
	\caption{A logoláshoz használt adatbázis struktúra: \textbf{log}}
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Név} 	& \textbf{Típus} 	& \textbf{Extra} & \textbf{Leírás} \\ 
		\hline
		ID & int & AUTO\_INCREMENT & a bejegyzés azonosítója \\
		\hline
		DEVICE & int &  & az eszköz azonosítója \\
		\hline
		TIMESTAMP & timestamp & CURRENT\_TIMESTAMP & a bejegyzés dátuma és ideje \\
		\hline
		LOGLEVEL & tinyint &  & a log típusa \\
		\hline
		MESSAGE & text &  & a logolt üzenet \\
		\hline
	\end{tabular} 
\end{table}


Az \textbf{envirnmentalsensor} és \textbf{wifisocket} táblák egyszer\H{u}en az eszközrõl történt egy leolvasás eredményét tárolják, meglétük nem létfontosságú, a legtöbb esetben elegendõ a legfrissebb adat, ami tetszõleges id?ben lekérdezhetõ. Ezzel szemben az nyitásérzékelõk állapota egyedül a \textbf{opendetector} táblából olvasható ki, mivel az eszköz csak állapotváltozás (nyitás, csukás) esetén ébred fel, egy bejegyzés megtételének erejéig.

A \textbf{log} táblát egyedül debugolás céljára használtam, de speciális LOGLEVEL byte értékek lefoglalásával akár postaláda jelleg\H{u} kommunikáció is implementálahtó az eszközök között.

%----------------------------------------------------------------------------
\section{Alternatívák}
%----------------------------------------------------------------------------

Cél volt az, hogy az egyes eszközök a lehetõ legkevésbé függjenek a központi egységtõl. Nyitva akartam hagyni annak a lehetõségét is, hogy ezen részegység funkcionalitása impementálható legyen bármilyen alternatív eszközre mint például egy androidos okostelefon, egy iPad, vagy akár egy böngészõ. Ennek érdekében példáult a hõmérséklet JSON formátumban is elérhetõ.



